// Initialize Socket.IO
const socket = io();

let currentDeviceId = null;
let chartData = {};

// Socket connection status
socket.on('connect', () => {
    updateServerStatus(true);
});

socket.on('disconnect', () => {
    updateServerStatus(false);
});

// Listen for sensor data
socket.on('sensor-data', (data) => {
    console.log('Received sensor data:', data);
    if (data.deviceId === currentDeviceId) {
        displaySensorData(data);
    }
});

// Listen for config updates
socket.on('config-update', (data) => {
    console.log('Config updated:', data);
    if (data.deviceId === currentDeviceId) {
        alert('C·∫•u h√¨nh ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn thi·∫øt b·ªã!');
    }
});

function updateServerStatus(connected) {
    const indicator = document.getElementById('serverStatus');
    const text = document.getElementById('serverStatusText');
    
    if (connected) {
        indicator.className = 'status-indicator online';
        text.textContent = 'ƒê√£ k·∫øt n·ªëi';
    } else {
        indicator.className = 'status-indicator';
        text.textContent = 'ƒêang k·∫øt n·ªëi...';
    }
}

// Load devices on page load
window.addEventListener('load', () => {
    refreshDevices();
});

async function refreshDevices() {
    try {
        const response = await fetch('/api/device/list');
        const data = await response.json();
        
        if (data.success) {
            displayDevices(data.devices);
        }
    } catch (error) {
        console.error('Error loading devices:', error);
    }
}

function displayDevices(devices) {
    const devicesList = document.getElementById('devicesList');
    devicesList.innerHTML = '';
    
    if (devices.length === 0) {
        devicesList.innerHTML = '<p>Ch∆∞a c√≥ thi·∫øt b·ªã n√†o ƒë∆∞·ª£c ƒëƒÉng k√Ω</p>';
        return;
    }
    
    devices.forEach(device => {
        const card = document.createElement('div');
        card.className = `device-card ${device.isOnline ? '' : 'offline'}`;
        
        card.innerHTML = `
            <div class="device-header">
                <div class="device-name">${device.name || device.deviceId}</div>
                <span class="device-status ${device.isOnline ? 'online' : 'offline'}">
                    ${device.isOnline ? 'Online' : 'Offline'}
                </span>
            </div>
            <div class="device-info">ID: ${device.deviceId}</div>
            <div class="device-info">Firmware: ${device.firmware || 'N/A'}</div>
            <div class="device-info">Last seen: ${formatDate(device.lastSeen)}</div>
        `;
        
        card.addEventListener('click', () => selectDevice(device.deviceId));
        devicesList.appendChild(card);
    });
}

function selectDevice(deviceId) {
    currentDeviceId = deviceId;
    socket.emit('subscribe-sensor', { deviceId });
    
    // Update UI
    document.getElementById('sensorSection').style.display = 'block';
    document.getElementById('configSection').style.display = 'block';
    
    document.getElementById('currentDeviceName').textContent = `üìä D·ªØ li·ªáu c·∫£m bi·∫øn - ${deviceId}`;
    
    // Load device details and sensor data
    loadDeviceData(deviceId);
    loadSensorData(deviceId);
    loadDeviceConfig(deviceId);
}

async function loadDeviceData(deviceId) {
    try {
        const response = await fetch(`/api/device/${deviceId}`);
        const data = await response.json();
        
        if (data.success && data.device.recentData) {
            displaySensorData(data.device.recentData);
        }
    } catch (error) {
        console.error('Error loading device data:', error);
    }
}

async function loadSensorData(deviceId) {
    try {
        const response = await fetch(`/api/sensor/data/${deviceId}?limit=50`);
        const data = await response.json();
        
        if (data.success && data.data.length > 0) {
            // Get latest data
            const latestData = data.data[data.data.length - 1];
            displaySensorData(latestData);
            
            // Prepare chart data
            prepareChartData(data.data);
        }
    } catch (error) {
        console.error('Error loading sensor data:', error);
    }
}

function displaySensorData(record) {
    const sensorDataDiv = document.getElementById('sensorData');
    sensorDataDiv.innerHTML = '';
    
    if (!record.sensors || record.sensors.length === 0) {
        sensorDataDiv.innerHTML = '<p>Ch∆∞a c√≥ d·ªØ li·ªáu c·∫£m bi·∫øn</p>';
        return;
    }
    
    record.sensors.forEach(sensor => {
        const card = document.createElement('div');
        card.className = 'sensor-card';
        
        card.innerHTML = `
            <h3>${getSensorTypeName(sensor.type)}</h3>
            <div class="value">${sensor.value.toFixed(1)}</div>
            <div class="unit">${sensor.unit}</div>
            <div style="margin-top: 10px; font-size: 0.8em; opacity: 0.8;">
                ${formatDate(record.timestamp)}
            </div>
        `;
        
        sensorDataDiv.appendChild(card);
    });
}

function prepareChartData(data) {
    // Group data by sensor type
    const sensorsByType = {};
    
    data.forEach(record => {
        record.sensors.forEach(sensor => {
            if (!sensorsByType[sensor.type]) {
                sensorsByType[sensor.type] = [];
            }
            sensorsByType[sensor.type].push({
                value: sensor.value,
                timestamp: new Date(record.timestamp)
            });
        });
    });
    
    chartData = sensorsByType;
    drawChart();
}

function drawChart() {
    const canvas = document.getElementById('sensorChart');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = canvas.offsetWidth;
    canvas.height = 300;
    
    if (Object.keys(chartData).length === 0) {
        return;
    }
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw chart for each sensor type
    const types = Object.keys(chartData);
    types.forEach((type, index) => {
        const data = chartData[type];
        const color = getColorForSensorType(type, index);
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const padding = 40;
        const maxValue = Math.max(...data.map(d => d.value));
        const minValue = Math.min(...data.map(d => d.value));
        const range = maxValue - minValue || 1;
        
        data.forEach((point, i) => {
            const x = padding + (i / (data.length - 1)) * (canvas.width - padding * 2);
            const y = canvas.height - padding - ((point.value - minValue) / range) * (canvas.height - padding * 2);
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        });
        
        ctx.stroke();
    });
}

function getColorForSensorType(type, index) {
    const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#00f2fe', '#43e97b'];
    return colors[index % colors.length];
}

function getSensorTypeName(type) {
    const names = {
        'temperature': 'üå°Ô∏è Nhi·ªát ƒë·ªô',
        'humidity': 'üíß ƒê·ªô ·∫©m',
        'pressure': 'üåä √Åp su·∫•t',
        'light': 'üí° √Ånh s√°ng',
        'motion': 'üë§ Chuy·ªÉn ƒë·ªông',
        'distance': 'üìè Kho·∫£ng c√°ch'
    };
    return names[type] || type;
}

async function loadDeviceConfig(deviceId) {
    try {
        const response = await fetch(`/api/config/${deviceId}`);
        const data = await response.json();
        
        if (data.success) {
            const config = data.config;
            document.getElementById('wifiSSID').value = config.wifi_ssid || '';
            document.getElementById('wifiPassword').value = config.wifi_password || '';
            document.getElementById('sendInterval').value = config.send_interval || 5000;
            document.getElementById('deviceId').value = config.device_id || deviceId;
        }
    } catch (error) {
        console.error('Error loading device config:', error);
    }
}

async function saveConfig() {
    if (!currentDeviceId) {
        alert('Vui l√≤ng ch·ªçn thi·∫øt b·ªã tr∆∞·ªõc');
        return;
    }
    
    const config = {
        wifi_ssid: document.getElementById('wifiSSID').value,
        wifi_password: document.getElementById('wifiPassword').value,
        send_interval: document.getElementById('sendInterval').value,
        device_id: document.getElementById('deviceId').value
    };
    
    try {
        const response = await fetch(`/api/config/${currentDeviceId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(config)
        });
        
        const data = await response.json();
        
        if (data.success) {
            alert('‚úÖ C·∫•u h√¨nh ƒë√£ ƒë∆∞·ª£c l∆∞u v√† g·ª≠i ƒë·∫øn thi·∫øt b·ªã!');
        } else {
            alert('‚ùå L·ªói khi l∆∞u c·∫•u h√¨nh');
        }
    } catch (error) {
        console.error('Error saving config:', error);
        alert('‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn server');
    }
}

function formatDate(dateString) {
    if (!dateString) return 'N/A';
    const date = new Date(dateString);
    return date.toLocaleString('vi-VN');
}

// ========================================
// Mock Data Functions
// ========================================

let autoGenerateInterval = null;

async function seedMockData() {
    try {
        updateMockStatus('ƒêang t·∫°o mock data...');
        
        const response = await fetch('/api/mock/seed', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                numDevices: 2,
                numDataPoints: 30
            })
        });
        
        const data = await response.json();
        
        if (data.success) {
            updateMockStatus(`‚úÖ ƒê√£ t·∫°o ${data.devicesCreated} thi·∫øt b·ªã v√† ${data.dataPointsCreated} ƒëi·ªÉm d·ªØ li·ªáu!`);
            refreshDevices();
        } else {
            updateMockStatus('‚ùå L·ªói khi t·∫°o mock data');
        }
    } catch (error) {
        console.error('Error seeding mock data:', error);
        updateMockStatus('‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn server');
    }
}

async function generateMockData() {
    try {
        updateMockStatus('ƒêang generate d·ªØ li·ªáu...');
        
        const response = await fetch('/api/mock/generate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        const data = await response.json();
        
        if (data.success) {
            updateMockStatus('‚úÖ ƒê√£ generate d·ªØ li·ªáu m·ªõi!');
            refreshDevices();
            
            // N·∫øu ƒëang xem device, refresh data
            if (currentDeviceId) {
                loadSensorData(currentDeviceId);
            }
        } else {
            updateMockStatus('‚ùå L·ªói khi generate d·ªØ li·ªáu');
        }
    } catch (error) {
        console.error('Error generating mock data:', error);
        updateMockStatus('‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn server');
    }
}

async function clearMockData() {
    if (!confirm('‚ö†Ô∏è B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a T·∫§T C·∫¢ d·ªØ li·ªáu kh√¥ng?')) {
        return;
    }
    
    try {
        const response = await fetch('/api/mock/clear', {
            method: 'DELETE'
        });
        
        const data = await response.json();
        
        if (data.success) {
            updateMockStatus('üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ d·ªØ li·ªáu');
            refreshDevices();
            
            // Clear current device display
            document.getElementById('sensorSection').style.display = 'none';
            document.getElementById('configSection').style.display = 'none';
            currentDeviceId = null;
        } else {
            updateMockStatus('‚ùå L·ªói khi x√≥a d·ªØ li·ªáu');
        }
    } catch (error) {
        console.error('Error clearing data:', error);
        updateMockStatus('‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn server');
    }
}

function startAutoGenerate() {
    if (autoGenerateInterval) {
        updateMockStatus('‚ö†Ô∏è Auto generate ƒë√£ ƒëang ch·∫°y');
        return;
    }
    
    updateMockStatus('‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu auto generate m·ªói 5 gi√¢y...');
    
    // Generate ngay l·∫≠p t·ª©c
    generateMockData();
    
    // Setup interval
    autoGenerateInterval = setInterval(() => {
        generateMockData();
    }, 5000);
}

function stopAutoGenerate() {
    if (autoGenerateInterval) {
        clearInterval(autoGenerateInterval);
        autoGenerateInterval = null;
        updateMockStatus('‚èπÔ∏è ƒê√£ d·ª´ng auto generate');
    } else {
        updateMockStatus('‚ö†Ô∏è Auto generate kh√¥ng ƒëang ch·∫°y');
    }
}

function updateMockStatus(message) {
    const statusDiv = document.getElementById('mockStatus');
    if (statusDiv) {
        statusDiv.textContent = message;
        
        // Auto clear sau 3 gi√¢y
        setTimeout(() => {
            if (statusDiv.textContent === message) {
                statusDiv.textContent = '';
            }
        }, 5000);
    }
}

